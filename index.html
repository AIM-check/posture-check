<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>右肘角度計測</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
  <video id="input_video" style="display:none;" autoplay></video>
  <canvas id="output_canvas"></canvas>
  <div id="angleDisplay" style="font-size: 20px; font-weight: bold; margin-top:10px;"></div>

  <script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const angleDisplay = document.getElementById('angleDisplay');

    const pose = new Pose.Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
    });

    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      smoothSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    pose.onResults(onResults);

    async function setupCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 640, height: 480 }
      });
      videoElement.srcObject = stream;
      await new Promise((resolve) => {
        videoElement.onloadedmetadata = () => {
          resolve(videoElement);
        };
      });
      videoElement.play();
    }

    function calculateAngle(a, b, c) {
      const ab = { x: b.x - a.x, y: b.y - a.y };
      const cb = { x: b.x - c.x, y: b.y - c.y };
      const dot = ab.x * cb.x + ab.y * cb.y;
      const magAB = Math.hypot(ab.x, ab.y);
      const magCB = Math.hypot(cb.x, cb.y);
      const angleRad = Math.acos(dot / (magAB * magCB));
      return Math.round(angleRad * (180 / Math.PI));
    }

    function onResults(results) {
      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (!results.poseLandmarks) return;

      drawConnectors(canvasCtx, results.poseLandmarks, Pose.POSE_CONNECTIONS, { color: '#00FF00' });
      drawLandmarks(canvasCtx, results.poseLandmarks, { color: '#FF0000', radius: 4 });

      const rShoulder = results.poseLandmarks[12];
      const rElbow = results.poseLandmarks[14];
      const rWrist = results.poseLandmarks[16];

      const angle = calculateAngle(rShoulder, rElbow, rWrist);
      angleDisplay.innerText = `右肘の角度: ${angle}°`;
    }

    async function run() {
      await setupCamera();
      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await pose.send({ image: videoElement });
        },
        width: 640,
        height: 480
      });
      camera.start();
    }

    // camera_utils.js が ESM に export 対応していないため Camera クラスを代替的に再定義
    class Camera {
      constructor(videoEl, config) {
        this.video = videoEl;
        this.onFrame = config.onFrame;
        this.width = config.width;
        this.height = config.height;
      }

      async start() {
        await setupCamera();
        const renderLoop = async () => {
          await this.onFrame();
          requestAnimationFrame(renderLoop);
        };
        renderLoop();
      }
    }

    run();
  </script>
</body>
</html>
